# 经典七大查找算法

首先经常在算法书籍中看到logN的身影，那么这个对数的底数是多少呢？
Weiss 在他的著作《数据结构与算法分析》中曾指出：在计算机科学中，除非有特殊的说明，否则所有的对数都是以2为底的。

查找是在大量信息中寻找一个特定的信息元素。
共7种常见的查找算法。其中二分查找，插值查找，斐波那契查找都可归为一类，插值查找

## 1.算法分类

1）静态查找和动态查找：

静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表

2）无序查找和有序查找

无序查找：被查找数列有序无序均可
有序查找：被查找数列必须为有序数列

## 2.具体算法

### 2.1顺序查找

顺序查找适合于存储结构为顺序存储或链表存储的线性表，为无序查找

基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较
，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败

顺序查找的时间复杂度为O(n)。

### 2.2二分查找

元素必须是有序的，如果是无序的要先进行排序

基本思想：也称为折半查找，属于有序查找算法。用给定k先与中间结点比较，中间节点把线性表分成2个子表，若相等则查找成功，若不相等，
再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

二分查找时间复杂度O(logn)

### 2.3插值查找
元素也必须是有序的
　
基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，而不是对半，可以提高查找效率

二分查找中查找点计算如下：
mid=(low+high)/2, 即mid=low+1/2*(high-low);
通过类比，可以将查找的点改进为如下：
mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，


插值查找时间复杂度O(logn)

### 2.4斐波那契查找

元素也必须是有序的

斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）
随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。

基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率

### 2.5树表查找

#### 2.5.1二叉树查找
元素不需要是顺序的，在插入的过程中排序
基本思想：二叉树查找是先对查找的数据生成树，然后再查找。

	复杂度，它和二分查找一样，插入和查找时间复杂度均为O(logn).但是在最坏的情况下仍然会有O(n)的时间复杂度,因为树没有保持平衡。
	
树表查找总结：

二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。
平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。
但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。
红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。

除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用


### 2.6分块查找

分块查找又称索引顺序查找，它是顺序查找的一种改进

基本思想：将n个数据元素按块有序划分为m块（m<=n）。每块中的节点不必有序，但块与块之间必须“按块有序”；即第1块中任一元素的关键字必须小于第
2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……

算法流程：
	（1）先选取各块中的最大关键字构成一个索引表
	（2）查找分2部分，先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后在已确定的块中用顺序法进行查找

### 2.7哈希查找

通过某种转换关系，使关键字适度的分散到指定大小的顺序结构中，越分散，则以后查找时间复杂度越小，空间复杂度越高
	
基本思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，
值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。

算法流程：
	（1）用给定的哈希函数构造哈希表
	（2）根据选择的冲突处理方法解决地址冲突（拉链法和线性探测法）
	（3）在哈希表上执行哈希查找
	
哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。
那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。
哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。

对于无冲突的Hash表而言，查找复杂度为O(1)



https://www.cnblogs.com/maybe2030/p/4715035.html#_labelTop































	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	